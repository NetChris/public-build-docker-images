---
stages:
  - Build and Push Image
  - Tests

variables:
  BASE_BUILD_IMAGE: ${CI_REGISTRY_IMAGE}
  REF_TAG: ${CI_COMMIT_REF_NAME}
  BUILD_ID: ${CI_PIPELINE_ID}
  IMAGE_SOURCE_REPOSITORY: ${CI_PROJECT_URL}
  IMAGE_REVISION: ${CI_COMMIT_SHA}

.build-then-push:
  image: docker:19.03.1
  services:
    - docker:19.03.1-dind
  script:
    - ./common/build.sh
    - echo "${CI_REGISTRY_PASSWORD}" | docker login --username ${CI_REGISTRY_USER} --password-stdin $CI_REGISTRY
    - ./common/push.sh
    - docker logout $CI_REGISTRY

.test:
  stage: Tests
  tags:
    - NetChris

Build and Push - Alpine:
  stage: Build and Push Image
  variables:
    VARIANT: alpine
  extends: 
    - .build-then-push

Build and Push - Docker:
  stage: Build and Push Image
  variables:
    VARIANT: docker
  extends: 
    - .build-then-push

Tests - Alpine:
  image: ${CI_REGISTRY_IMAGE}/${CI_COMMIT_REF_NAME}/alpine:${CI_PIPELINE_ID}
  extends: 
    - .test
  script:
    - curl -X GET https://${CI_REGISTRY}

# Run a test that essentially re-builds the Docker image _inside_ the newly-pushed Docker image. INCEPTION!!!! :)
Tests - Docker Build:
  image: ${CI_REGISTRY_IMAGE}/${CI_COMMIT_REF_NAME}/docker:${CI_PIPELINE_ID}
  variables:
    VARIANT: docker
    BASE_BUILD_IMAGE: ${CI_REGISTRY_IMAGE}
    REF_TAG: ${CI_COMMIT_REF_NAME}
    BUILD_ID: ${CI_PIPELINE_ID}
    IMAGE_SOURCE_REPOSITORY: ${CI_PROJECT_URL}
    IMAGE_REVISION: ${CI_COMMIT_SHA}
  extends: 
    - .test
  script:
    - ./docker/test-build.sh
